âœ… Approach 1: Array-Based (Vector) â€“ 2-Pass Method

   ğŸ”¹ What we did
      Used a vector<int> arr to store node values.
      Pass 1: Collected values of nodes at odd positions (1st, 3rd, 5th...).
      Pass 2: Collected values of nodes at even positions (2nd, 4th, 6th...).
      Final Pass: Wrote all values back to the original linked list node-by-node.

   ğŸ”¹ How we used external memory
      Created a vector<int> of size n (same as number of nodes).
      Temporarily held all node values during rearrangement.

   ğŸ”¹ Time Complexity (TC)
      First pass to collect odd values: O(n/2)
      Second pass to collect even values: O(n/2)
      Final pass to overwrite list: O(n)

      âœ… Total: O(n)

   ğŸ”¹ Space Complexity (SC)
      âŒ O(n) â€” due to vector<int> arr holding all node values temporarily.

   ğŸ”¹ Pros
      Very easy to understand and implement.
      Less error-prone (no pointer manipulation).
      Works for both SLL and DLL without modifying pointers.

   ğŸ”¹ Cons
      Not an in-place solution â€” modifies data, not structure.
      Uses external memory â†’ not optimal for large datasets.

-----------------------------------------------------------------

âœ… Approach 2: Two-Pointer In-Place (Odd-Even Links)

   ğŸ”¹ What we did
      Used two pointers:
      -   odd to track current odd-position node
      -   even to track current even-position node
      Rearranged actual pointers (next, and back for DLL) to reorder nodes.
      At the end, connected odd list tail to even list head.

   ğŸ”¹ How we used memory
      No external data structures.
      Pure pointer manipulation.
      Used only constant extra space (just 2â€“3 pointers).

   ğŸ”¹ Time Complexity (TC)
      Only one traversal: each node visited once â†’ âœ… O(n)

   ğŸ”¹ Space Complexity (SC)
      âœ… O(1) â€” In-place, no extra space used.

   ğŸ”¹ Pros
      âœ… Fully in-place solution.
      âœ… Maintains node object identity and links.
      âœ… Memory-efficient â€” ideal for large linked lists.

   ğŸ”¹ Cons
      Slightly more complex pointer manipulation.
      Must handle edge cases carefully (1-node or NULL).