ðŸ” Finding the length of the longest subarray with sum â‰¤ k

   1. brute
   2. better
   3. optimal

   âœ… 1. Brute Force Approach
      
   ðŸ”§ Method:

      Start from every index i = 0 to n-1
      For each i, run a loop from j = i to n-1
      Keep summing arr[j] and check if sum â‰¤ k
      If yes â†’ update maxLen
      If sum > k â†’ break (no point checking longer subarrays from the same start)

   ðŸ§  Time Complexity: O(nÂ²) â€” Nested loops

   âœ… 2. Better â€“ Sliding Window (for Non-negative Elements)
   
   ðŸ”§ Method:

      Use two pointers l and r
      Expand r to include elements
      Shrink l (from the left) only while sum > k
      Update maxLen = max(maxLen, r - l + 1) if sum â‰¤ k

   ðŸ§  Time Complexity: O(n+n)
   (each element is visited at most twice: once by r, once by l)

   âœ… 3. Optimal â€“ Shrink Lazily (Greedy Shrinking)
   
   ðŸ”§ Method:

      Similar to sliding window, but instead of while, use if to shrink once
      Avoid shrinking unless absolutely necessary
      This maintains the current window as long as possible (greedy expansion)

   ðŸ§  Time Complexity: O(n) 
   â€” because we touch each element once